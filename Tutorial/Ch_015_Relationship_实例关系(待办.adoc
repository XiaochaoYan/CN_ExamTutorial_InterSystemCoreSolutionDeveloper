
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
ifndef::imagesdir[:imagesdir: ../Img]

= Relationship 实例间关系 +

=== 在 InterSystem中 关系有如下特点/限制 +
1. 单条关系必须是 二元的Binary 的，即这条关系必须要是 1对1 的，即 A->B 或 A->A 这种。不存在 A->B&C 的关系（但是可以多条关系叠加 +
2. 只有继承了 %Persistent 父类的 实例Object/类Class 才能被定义关系 +
3. 关系是 双向的bidrectional 的，如 A->B 关系存在，则 B->A 关系也需要被定义 +
4. 关系自动会保证 引用完整性referential integrity，即 第123号记录 能在 表B（子） 中被找到且存在 A(亲)->B（子） 表间关系，则对应的记录在 表A（亲） 中也存在，如果需要删除 表A（亲）中的 123号记录，则需要先删除 表B（子）中的123号记录 +

image::IRIS_025.gif[]

5. 关系会自动管理 内存中in-memory / 硬盘上on-disk 的数据行为 +
6. 关系一般比 数据集合collection 拥有更好的 并发性能 和 扩展性

*另外：关系Realationship 属于 类Class 的一种 属性Property，依靠的时 []方括号 中的 关键词Keyword 声明，所以可以和其他 关键词Keyword 一起混用。 +

= 常用语法 +

Relationship Name As classname [ Cardinality = cardinality_type, Inverse = inverseProp ]; +
其中 Cardinality 指连接关系中这个 类Class 随对应的部分，如 1ToN 关系中就分 One / Many 两个部分，下方例子，对应的是 Many 部分。 +
其中 Inverse 指连接关系中的另一个 类Classs，如当前 类Class 对应的时 Many，Inverse填的则对应 One的 类Class 的名字 +

=== 实际应用例子 +

----
Relationship Employees As MyApp.Employee [ Cardinality = many, Inverse = Employer ];
----
= 实例间关系的类型 +

=== 1. 1ToN 关系 +

特点： A->B 一个 类A的实例 对应 0或更多条的 的 类B的实例, 但是 A B 两个表格相互独立 +
one instance of class A is associated with zero or more instances of class B +
如果有一家公司，每一个公司(类A) 必定对应 0或者更多的 雇员(类B) +
For example, a company class may define a one-to-many relationship with an employee class. In this case, there may be zero or more employee objects associated with each company object. +

当 任意 类A 或 类B 中有新的实例被创建时，这个新实例 *不一定* 会和关系中另一类有对应关系 +
When an instance of either class is created, it may or may not be associated with an instance of the other class. +

当 类B 和 类A的123号实例 有关系时，这个关系是可以被删除或者修改的，类B实例 不一定要和 类A实例 有对应关系。反之亦然。（此处公司雇员的例子不是特别好 但是雇员没公司的情况也是被定义允许的 +
If an instance of class B is associated with a given instance of class A, this association can be removed or changed. The instance of class B can be associated with a different instance of class A. The instance of class B does not have to have any association with an instance of class A (and vice versa). +

=== 2. 亲子继承 关系 +

特点： A->B 一个 类A的实例 对应 0或更多条的 的 类B的实例，但是 B表 依赖于 A表 。 +

B表中的实例如果在A表中没有对应，则对它的保存操作会失败。 +
When an instance of the class B is saved, it must be associated with an instance of class A. If you attempt to save the instance, and that association is not defined, the save action fails. +

同时 A B 两个表中的实例关系不能被修改，即 B表123号实例 在和 A表456号实例 绑定后，不能改成和 A表789号实例绑定 +
The association cannot be changed. That is, you cannot associate the instance of class B with a different instance of class A. +

如果 A表中一个实例被删除了，B表中所有与这个A表实例相关的记录都会被删除。（类似SQL中的 ON DELTE CASCADE +
If the instance of class A is deleted, all associated instances of class B are deleted as well. +
但是当你删除B表实例时，A表实例不会有任何影响。 +
You can delete an instance of class B. Class A is not required to have associated instances of class B. +

=== 3. N To N + 
特点: N对N 关系的实现需要靠一个 桥接Bridge 类来实现。即 A->B<-C 这样两段 1ToN 关系 串联。 +

承担交接作用的 DoctorPatient 类 +
----
Class MN.DoctorPatient Extends %Persistent
{

Relationship Doctor As MN.Doctor [ Cardinality = one, Inverse = Bridge ];

Index DoctorIndex On Doctor;

Relationship Patient As MN.Patient [ Cardinality = one, Inverse = Bridge ];

Index PatientIndex On Patient;
}
----
原有的 Doctor 类 +
----
Class MN.Doctor Extends %Persistent
{

Property Name;

Property Specialty;

Relationship Bridge As MN.DoctorPatient [ Cardinality = many, Inverse = Doctor ];

}
----
原有的 Patient 类 +
----
Class MN.Patient Extends %Persistent
{

Property Name;

Property Address;

Relationship Bridge As MN.DoctorPatient [ Cardinality = many, Inverse = Patient ];

}
----
= 官方文档 +
1. https://docs.intersystems.com/iris20212/csp/docbook/DocBook.UI.Page.cls?KEY=GOBJ_relationships[EN_实例间关系] +
